{
  "name": "DECO",
  "tagline": "Decorated Concurrency",
  "body": "Decorated Concurrency\r\n===========\r\n\r\nA simplified parallel computing model for Python.\r\nDECO automatically parallelizes Python programs, and requires minimal modifcations to existing serial programs.\r\n\r\nInstall using pip:\r\n\r\n```\r\npip install deco\r\n```\r\n\r\nGeneral Usage\r\n---------------\r\n\r\nUsing DECO is as simple as finding, or creating, two functions in your Python program.\r\nThe first function is the one we want to run in parallel, and is decorated with `@concurrent`.\r\nThe second function is the function which calls the `@concurrent` function and is decorated with `@synchronized`.\r\nDecorating the second function is optional, but provides some very cool benefits.\r\nLet's take a look at an example.\r\n\r\n\r\n```python\r\n@concurrent # We add this for the concurrent function\r\ndef process_lat_lon(lat, lon, data):\r\n  #Does some work\r\n  return result\r\n\r\n@synchronized # And we add this for the function which calls the concurrent function\r\ndef process_data_set(data):\r\n  results = defaultdict(dict)\r\n  for lat in range(...):\r\n    for lon in range(...):\r\n      results[lat][lon] = process_lat_lon(lat, lon, data)\r\n  return results\r\n```\r\n\r\nThat's it, two lines of changes is all we need in order to parallelize this program.\r\nNow this program will make use of all the cores on the machine it's running on, allowing it to run significantly faster.\r\n\r\nWhat it does\r\n-------------\r\n\r\n - The `@concurrent` decorator use multiprocessing.pool to parallelize calls to the target function\r\n - Indexed based mutation of function arguments is handled automatically, which pool cannot do\r\n - The `@synchronized` decorator automatically inserts synchronization events \r\n - It also automatically refactors assignments of the results of `@concurrent` function calls to happen during synchronization events\r\n \r\nHow it works\r\n-------------\r\n\r\nFor an in depth discussion of the mechanisms at work, we wrote a paper for a class\r\nwhich [can be found here](https://drive.google.com/file/d/0B_olmC0u8E3gWTBmN3pydGxHdEE/view).\r\n\r\nAs an overview, DECO is mainly just a smart wrapper for Python's multiprocessing.pool.\r\nWhen `@concurrent` is applied to a function it replaces it with calls to pool.apply_async.\r\nAdditionally when arguments are passed to pool.apply_async, DECO replaces any index mutable objects with proxies, allowing it to detect and synchronize mutations of these objects.\r\nThe results of these calls can then be obtained by calling wait() on the concurrent function, invoking a synchronization event.\r\nThese events can be placed automatically in your code by using the `@synchronized` decorator on functions that call `@concurrent` functions.\r\nAdditionally while using `@synchronized`, you can directly assign the result of concurrent function calls to index mutable objects.\r\nThese assignments get refactored by DECO to automatically occur during the next synchronization event.\r\nAll of these means that in many cases, parallel programming using DECO appears exactly the same as simpler serial programming.\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}